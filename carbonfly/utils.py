from __future__ import annotations
"""
carbonfly
    a lightweight, easy-to-use Python API and 
    toolbox for indoor CO2 CFD simulations in Grasshopper
    based on OpenFOAM and WSL

- Author: Qirui Huang
- License: LGPL-3.0
- Website: https://github.com/RWTH-E3D/carbonfly
"""

# carbonfly/utils.py
"""
Utility functions for generating OpenFOAM-compatible file structures.
"""
import math
from typing import Optional


def foam_header(
    object_name: str,
    of_class: str = "dictionary",
    location: str = None,
    *,
    of_version: str = "10",
    project_name: str = "carbonfly",
    author: str = "Qirui Huang",
    project_url: str = "https://github.com/RWTH-E3D/carbonfly"
) -> str:
    """
    Return an OpenFOAM-style header with Carbonfly attribution.

    Args:
        object_name:    OpenFOAM object name (e.g., 'snappyHexMeshDict', 'U').
        of_class:       OpenFOAM class (e.g., 'dictionary', 'volScalarField', 'volVectorField').
        of_version:     OpenFOAM version label to show in the banner.
        project_name:   Project name for attribution line.
        author:         Author handle for attribution line.
        project_url:    URL for the project.

    Usage:
        lines = [foam_header("snappyHexMeshDict")]
    """
    banner = (
        "/*--------------------------------*- C++ -*----------------------------------*\\\n"
        "  =========                 |\n"
        "  \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox\n"
        "   \\\\    /   O peration     | Website:  https://openfoam.org\n"
       f"    \\\\  /    A nd           | Version:  {of_version}\n"
        "     \\\\/     M anipulation  |\n\n"
    )
    attribution = (
        f"Generated by {project_name}\n"
        f"  - Author: {author}\n"
        f"  - Website: {project_url}\n"
        "\\*---------------------------------------------------------------------------*/\n\n"
        "FoamFile\n"
        "{\n"
         "    format      ascii;\n"
        f"    class       {of_class};\n"
    )
    if location:
        attribution += f"    location    \"{location}\";\n"

    attribution += (
        f"    object      {object_name};\n"
        "}\n\n"
        "// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n"
    )

    return banner + attribution


def unit_scale_to_m(unit: str) -> float:
    u = (unit or "mm").strip().lower()
    if u == "mm": return 1e-3
    if u == "cm": return 1e-2
    if u == "m":  return 1.0
    raise ValueError("unit must be 'mm'|'cm'|'m'")


def co2_generation_rate(age: float, met: float, gender: str | None = None):
    """
    Get CO2 generation rate (L/s) based on mean body mass in each age group.
    
    Args:
        age: Age in float.
        met: Level of physical activity (met), met must be one of [1.0, 1.2, 1.4, 1.6, 2.0, 3.0, 4.0].
        gender: "male", "female", None (default returns average for both genders).

    Returns:
        A dict contains
            "mass" (mean body mass, kg), 
            "BMR" (Basal Metabolic Rate, MJ/day), 
            "CO2" (CO2 generation rate, L/s)
    
    Source:
        Persily and De Jonge, Carbon dioxide generation rates for building
        occupants, Indoor Air 27 (5) (2017) 868–879. doi:10.1111/ina.12383

    """
    met_levels = [1.0, 1.2, 1.4, 1.6, 2.0, 3.0, 4.0]

    # Data is grouped by [min_age, max_age, mass, BMR, CO2 list...]
    CO2_generation_table = {
        "male": [
            (None, 1,   8.0, 1.86, [0.0009,0.0011,0.0013,0.0014,0.0018,0.0027,0.0036]),
            (1, 3,     12.8, 3.05, [0.0015,0.0018,0.0021,0.0024,0.0030,0.0044,0.0059]),
            (3, 6,     18.8, 3.90, [0.0019,0.0023,0.0026,0.0030,0.0038,0.0057,0.0075]),
            (6, 11,    31.9, 5.14, [0.0025,0.0030,0.0035,0.0040,0.0050,0.0075,0.0100]),
            (11, 16,   57.6, 7.02, [0.0034,0.0041,0.0048,0.0054,0.0068,0.0102,0.0136]),
            (16, 21,   77.3, 7.77, [0.0037,0.0045,0.0053,0.0060,0.0075,0.0113,0.0150]),
            (21, 30,   84.9, 8.24, [0.0039,0.0048,0.0056,0.0064,0.0080,0.0120,0.0160]),
            (30, 40,   87.0, 7.83, [0.0037,0.0046,0.0053,0.0061,0.0076,0.0114,0.0152]),
            (40, 50,   90.5, 8.00, [0.0038,0.0046,0.0054,0.0062,0.0077,0.0116,0.0155]),
            (50, 60,   89.5, 7.95, [0.0038,0.0046,0.0054,0.0062,0.0077,0.0116,0.0154]),
            (60, 70,   89.5, 6.84, [0.0033,0.0040,0.0046,0.0053,0.0066,0.0099,0.0133]),
            (70, 80,   83.9, 6.57, [0.0031,0.0038,0.0045,0.0051,0.0064,0.0095,0.0127]),
            (80, None, 76.1, 6.19, [0.0030,0.0036,0.0042,0.0048,0.0060,0.0090,0.0120]),
        ],
        "female": [
            (None, 1,   7.7, 1.75, [0.0008,0.0010,0.0012,0.0014,0.0017,0.0025,0.0034]),
            (1, 3,     12.3, 2.88, [0.0014,0.0017,0.0020,0.0022,0.0028,0.0042,0.0056]),
            (3, 6,     18.3, 3.59, [0.0017,0.0021,0.0024,0.0028,0.0035,0.0052,0.0070]),
            (6, 11,    31.7, 4.73, [0.0023,0.0027,0.0032,0.0037,0.0046,0.0069,0.0092]),
            (11, 16,   55.9, 6.03, [0.0029,0.0035,0.0041,0.0047,0.0058,0.0088,0.0117]),
            (16, 21,   65.9, 6.12, [0.0029,0.0036,0.0042,0.0047,0.0059,0.0089,0.0119]),
            (21, 30,   71.9, 6.49, [0.0031,0.0038,0.0044,0.0050,0.0063,0.0094,0.0126]),
            (30, 40,   74.8, 6.08, [0.0029,0.0035,0.0041,0.0047,0.0059,0.0088,0.0118]),
            (40, 50,   77.1, 6.16, [0.0029,0.0036,0.0042,0.0048,0.0060,0.0090,0.0119]),
            (50, 60,   77.5, 6.17, [0.0030,0.0036,0.0042,0.0048,0.0060,0.0090,0.0120]),
            (60, 70,   76.8, 5.67, [0.0027,0.0033,0.0038,0.0044,0.0055,0.0082,0.0110]),
            (70, 80,   70.8, 5.45, [0.0026,0.0032,0.0037,0.0042,0.0053,0.0079,0.0106]),
            (80, None, 64.1, 5.19, [0.0025,0.0030,0.0035,0.0040,0.0050,0.0075,0.0101]),
        ],
    }

    if age < 0 or age > 100:
        raise ValueError("age must be between 0 and 100")
    if met not in met_levels:
        raise ValueError(f"met must be one of {met_levels}")
    idx = met_levels.index(met)

    def _find_one(g: str):
        for lo, hi, mass, bmr, co2_list in CO2_generation_table[g]:
            # lo/hi=None indicates no lower/upper limit.
            if (lo is None or age >= lo) and (hi is None or age < hi):
                return mass, bmr, co2_list[idx]
        raise ValueError(f"No suitable age range found in the table {g} for {age}.")

    if gender is None:
        m_mass, m_bmr, m_co2 = _find_one("male")
        f_mass, f_bmr, f_co2 = _find_one("female")
        # get average
        return {
            "mass": (m_mass + f_mass) / 2,
            "BMR": (m_bmr + f_bmr) / 2,
            "CO2": (m_co2 + f_co2) / 2,
        }
    else:
        gender = gender.lower()
        if gender not in CO2_generation_table:
            raise ValueError("gender must be one of {male,female}")
        m, b, c = _find_one(gender)
        return {"mass": m, "BMR": b, "CO2": c}


def _cpe_for_area(area_m2, cpe1, cpe10):
    """
    logarithmic interpolation between 1 m^2 and 10 m^2.
    """
    A = max(1e-9, area_m2)
    if A <= 1.0:
        return cpe1
    if A >= 10.0:
        return cpe10
    t = math.log10(A)  # log10 from 1 to 10 maps to 0..1
    return cpe1 + t * (cpe10 - cpe1)

def _hd_bucket(h_over_d):
    """
    Map to one of: '0.25' (for h/d ≤ 0.25), '1', '5'.
    """
    if h_over_d <= 0.25:
        return "0.25"
    return "1" if h_over_d < 3.0 else "5"

def _lookup_cpe(zone, h_over_d, table):
    z = zone.upper().strip()
    if z not in ("A", "B", "C", "D", "E"):
        raise ValueError("zone must be A/B/C/D/E")
    key = (z, _hd_bucket(h_over_d))
    if key not in table:
        raise KeyError(f"No Cpe for zone={z}, h/d bucket={key[1]}")
    return table[key]

def wind_pressure_en1991(
    vb0: float,
    z: float,
    h: float,
    d: float,
    window_size: float,
    zone: str,
    terrain: Optional[int] = 4,
    c_dir: Optional[float] = 1.0,
    c_season: Optional[float] = 1.0,
    c0: Optional[float] = 1.0,
    rho: Optional[float] = 1.25,
    k_i: Optional[float] = 1.0
) -> dict:
    """
    Computes peak and surface wind pressure for vertical walls of rectangular plan buildings (h/d <=5 and height <= 200m), based on DIN EN 1991-1-4:2010-12.

    Notes:
        For other building types, please see DIN EN 1991-1-4:2010-12.

    Args:
        vb0: fundamental value of the basic wind velocity v_b,0 [m/s] (from National Annex map, 10 m, terrain II, 50 yr)
        z: height above ground level of the measured/evaluated point [m]
        h: height of the building [m]
        d: length of the building [m]
        window_size: window size in [m^2]
        zone: External pressure zones, A/B/C on side/roof edges along the flow, D windward face, and E leeward face. Schematic (Fig. 7.5) see below:
            Top view:
                           <- - - d (length)  - ->
                           -----------------------     ^
                           |                     |     |
                wind --> D |                     | E   b (width)
                           |                     |     |
                           -----------------------     -
                D = windward face (positive pressure / stagnation)
                E = leeward face (negative pressure / wake suction)
            Side view:
                           <- - - d (length)  - ->
                           -----------------------     ^
                           |   |         |       |     |
                wind -->   | A |    B    |   C   |     | h (height)
                           |___|_________|_______|     _
                           <- - - e - - ->
                               <- 4/5 e ->
                           Where: e = b or 2h, whichever is smaller
                A: leading corner band (strongest suction)
                B: intermediate edge band
                C: outer side/roof band
        terrain: terrain type, 0/1/2/3/4, default: 4, corresponding to Type 0/I/II/III/IV:
            0: Sea, coastal area exposed to the open sea.
            1: Lakes or area with negligible vegetation and without obstacles.
            2: Area with low vegetation such as grass and isolated obstacles (trees, buildings) with separations of at least 20 obstacle heights.
            3: Area with regular cover of vegetation or buildings or with isolated obstacles with separations of maximum 20 obstacle heights (such as villages, suburban terrain, permanent forest).
            4: Area in which at least 15 % of the surface is covered with buildings and their average height exceeds 15 m.
        c_dir: directional factor, for various wind directions may be found in the National Annex. The recommended value is 1.0.
        c_season: season factor, may be given in the National Annex. The recommended value is 1.0.
        c0: orography factor, taken as 1.0 unless otherwise specified. Note: Information on c0 may be given in the National Annex. If the orography is accounted for in the basic wind velocity, the recommended value is 1.0.
        rho: air density in kg/m3. The default value is 1.25 kg/m3.
        k_i: turbulence factor. The value of k_i may be given in the National Annex. The recommended value for k_i is 1.0.

    Returns:
      {'we': wind pressure on the external surface [Pa],
       'cpe': external pressure coefficients for vertical walls of rectangular plan buildings [-],
       'qp': peak velocity pressure [Pa],
       'vm': mean wind speed [m/s],
       'Iv': turbulence intensity,
       'cr': roughness factor,
       'vb': basic wind velocity [m/s]}
    """
    if z > 200:
        raise ValueError("z must be smaller than 200 m")

    # Table 4.1 - Terrain categories and terrain parameters
    terrain_table = {
        0: {"z0": 0.003, "zmin": 1.0},  # type 0
        1: {"z0": 0.010, "zmin": 1.0},  # type I
        2: {"z0": 0.050, "zmin": 2.0},  # type II
        3: {"z0": 0.300, "zmin": 5.0},  # type III
        4: {"z0": 1.000, "zmin": 10.0}, # type IV
    }
    if terrain not in terrain_table:
        raise ValueError("terrain must be 0/1/2/3/4 (corresponding to 0/I/II/III/IV)")

    # C_pe table from EN 1991-1-4 (Table 7.1)
    # C_pe,10
    ext_p_coef_10_table = {
        # ("zone", "h/d"): C_pe
        ("A", "0.25"): -1.2,  ("A", "1"): -1.2,  ("A", "5"): -1.2,
        ("B", "0.25"): -0.8,  ("B", "1"): -0.8,  ("B", "5"): -0.8,
        ("C", "0.25"): -0.5,  ("C", "1"): -0.5,  ("C", "5"): -0.5,
        ("D", "0.25"): +0.7,  ("D", "1"): +0.8,  ("D", "5"): +0.8,
        ("E", "0.25"): -0.3,  ("E", "1"): -0.5,  ("E", "5"): -0.7,
    }
    # C_pe,1
    ext_p_coef_1_table = {
        # ("zone", "h/d"): C_pe
        ("A", "0.25"): -1.4,  ("A", "1"): -1.4,  ("A", "5"): -1.4,
        ("B", "0.25"): -1.1,  ("B", "1"): -1.1,  ("B", "5"): -1.1,
        ("C", "0.25"): -0.5,  ("C", "1"): -0.5,  ("C", "5"): -0.5,
        ("D", "0.25"): +1.0,  ("D", "1"): +1.0,  ("D", "5"): +1.0,
        ("E", "0.25"): -0.3,  ("E", "1"): -0.5,  ("E", "5"): -0.7,
    }
    h_over_d = h / d
    if h_over_d > 5.0:
        raise ValueError("h/d must be <= 5")

    # get cpe based on window size from ext_p_coef_10_table and ext_p_coef_1_table using log interpolation
    h_over_d = h / d
    cpe10 = _lookup_cpe(zone, h_over_d, ext_p_coef_10_table)
    cpe1  = _lookup_cpe(zone, h_over_d, ext_p_coef_1_table)
    cpe    = _cpe_for_area(window_size, cpe1, cpe10)

    z0   = terrain_table[terrain]["z0"]
    zmin = terrain_table[terrain]["zmin"]

    z_eff = max(z, zmin)    # (4.4) c_r(z) = c_r(z_min) for z <= z_min

    # (4.1) Basic wind velocity v_b = c_dir * c_season * v_b,0
    vb = c_dir * c_season * vb0

    # (4.5) k_r = 0.19 * (z_0 / z_0,II)^0.07
    # where:
    # z_0,II = 0.05 m (terrain category II, Table 4.1)
    kr = 0.19 * (z0 / 0.05) ** 0.07

    # (4.4) c_r(z) = k_r * ln(z / z0) for z_min <= z <= z_max
    cr = kr * math.log(z_eff / z0)

    # (4.3) v_m(z) = c_r(z) * c_0(z) * v_b
    vm = cr * c0 * vb

    # (4.7) I_v(z) = k_i / (c0(z) * ln(z / z_0))
    Iv = k_i / (c0 * math.log(z_eff / z0))

    # (4.8) q_p(z) = 0.5 * rho * v_m(z)^2 * (1 + 7 * I_v(z))
    qp = 0.5 * rho * vm**2 * (1 + 7 * Iv)

    # (5.1) w_e = q_p(z_e) * C_pe
    we = qp * cpe

    return {"we": we, "cpe": cpe, "qp": qp, "vm": vm, "Iv": Iv, "cr": cr, "vb": vb}


def air_exchange_rate_maas1995(A_eff: float, u: float, H: float, delta_theta: float) -> float:
    """
    Air exchange rate in m3/h using Maas' formula:
    Qdot = 3600 * 1/2 * A_eff * sqrt(C1 * u^2 + C2 * H * delta_theta + C3)

    Source:
    Anton Maas. Experimental quantification of air exchange during window ventilation. PhD thesis, University of Kassel, Kassel, 1995.
    URL https://www.uni-kassel.de/fb6/bpy/de/forschung/abgeschlprojekte/pdfs/maas_diss.pdf

    Args:
        A_eff: effective opening area in m^2
        u: outdoor wind speed (10 m) in m/s
        H: height of the window sash in m
        delta_theta: temperature difference between the inside and outside in K

    Returns:
        Qdot: air exchange rate through the opening in m3/h
    """
    C1 = 0.0056
    C2 = 0.0037
    C3 = 0.012

    inner = C1 * (u ** 2) + C2 * H * delta_theta + C3
    if inner < 0:
        inner = 0.0  # avoid negative inner
    Qdot = 3600.0 * 0.5 * A_eff * math.sqrt(inner)
    return Qdot
